# Модуль kcp

```lua
kcp.connect(
    address: str,
    port: int
) --> KcpSocket
```

Открывает **KCP**-сокет, привязанный к указанному адресу и порту

Класс **KcpSocket** имеет следующие методы:
```lua
-- Отправляет массив байт
socket:send(Bytearray|table|str)

-- Читает полученные данные
socket:recv(
    -- Максимальный размер читаемого массива байт
    length: int
) -> nil|Bytearray
-- В случае ошибки возвращает nil (сокет закрыт или несуществует).
-- Если данных пока нет, возвращает пустой массив байт.

-- Закрывает сокет
socket:close()

-- Возвращает количество доступных для чтения байт данных
socket:available() --> int

-- Возвращает адрес и порт, на которые привязан сокет
socket:get_address() --> str, int
```

```lua
kcp.open(
    port: int,
    callback: function(KcpSocket)
) --> SocketServer
```

Открывает **KCP**-сервер на указанном порту

(см. **SocketServer** [здесь](https://github.com/MihailRis/voxelcore/blob/main/doc/ru/scripting/builtins/libnetwork.md?plain=1#L88))

При получении пакета от ранее не зарегистрированного отправителя, модуль будет создавать для него **KcpSocket** и вызывать **callback**, передавая в него этот сокет

При вызове **close** у данного сокета, отправитель будет считаться не зарегистрированным

> [!WARNING]
> Учтите, что в **KCP** отсутствует рукопожатие и проверка на доступность получателя
> , поэтому вам нужно будет это реализовать самостоятельно, поверх **KCP**