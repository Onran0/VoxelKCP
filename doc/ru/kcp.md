# Модуль kcp

```lua
kcp.connect(
    address: str,
    port: int
) --> KcpSocket
```

Открывает **KCP**-сокет, привязанный к указанному адресу и порту

Класс **KcpSocket** имеет следующие методы:
```lua
-- Отправляет массив байт
socket:send(Bytearray|table|str)

-- Читает полученные данные
socket:recv(
    -- Максимальный размер читаемого массива байт
    length: int
) -> nil|Bytearray
-- В случае ошибки возвращает nil (сокет закрыт или несуществует).
-- Если данных пока нет, возвращает пустой массив байт.

-- Закрывает сокет
socket:close()

-- Возвращает количество доступных для чтения байт данных
socket:available() --> int

-- Устанавливает MTU для сокета
-- По умолчанию MTU равен 1400
socket:set_mtu(mtu: int)

-- Устанавливает размеры окон для сокета
-- По умолчанию равны 32 и 128
socket:set_window_size(send: int, recv: int)

-- Возвращает текущий MTU сокета
socket:get_mtu() --> int

-- Возвращает текущие размеры окон сокета (send, recv)
socket:get_window_size() --> int, int

-- Возвращает сумму количества сегментов, которые ожидают отправки и количества сегментов, получение которых ещё не подтвердилось
socket:unconfirmed_segments() --> int

-- Включает или выключает nodelay-режим
socket:set_nodelay(nodelay: bool)

-- Устанавливает целевой интервал обновления сокета в миллисекундах
socket:set_interval(interval: int)

-- Устанавливает количество пропусков для быстрой переотправки, после которых пакет считается потерянным
-- Если передать 0, то быстрая переотправка будет отключена
-- По умолчанию быстрая переотправка отключена
socket:set_resend(interval: int)

-- Включает или выключает контроль перегрузки
-- Отключение может как перегрузить сеть, так и увеличить пропускную способность отправки
-- По умолчанию включён
socket:set_congestion_control(enabled: bool)

-- Проверяет включен ли nodelay-режим
socket:get_nodelay() --> bool

-- Возвращает интервал обновления сокета в миллисекундах
socket:get_interval() --> int

-- Возвращает количество пропусков для быстрой отправки, после которых пакет считается потерянным
-- Возввращает 0, если быстрая отправка отключена
socket:get_resend() --> int

-- Проверяет включен ли контроль перегрузки
socket:is_congestion_control_enabled() --> bool

-- Возвращает адрес и порт, на которые привязан сокет
socket:get_address() --> str, int
```

```lua
kcp.open(
    port: int,
    callback: function(KcpSocket)
) --> SocketServer
```

Открывает **KCP**-сервер на указанном порту

(см. **SocketServer** [здесь](https://github.com/MihailRis/voxelcore/blob/main/doc/ru/scripting/builtins/libnetwork.md?plain=1#L88))

При получении пакета от ранее не зарегистрированного отправителя, модуль будет создавать для него **KcpSocket** и вызывать **callback**, передавая в него этот сокет

При вызове **close** у данного сокета, отправитель будет считаться не зарегистрированным

> [!WARNING]
> Учтите, что в **KCP** отсутствует рукопожатие и проверка на доступность получателя
> , поэтому вам нужно будет это реализовать самостоятельно, поверх **KCP**

```lua
function kcp.set_auto_update(autoupdate: bool)
```

Включает или выключает автообновление (автоматический вызов kcp.update() в on_world_tick).
Отключайте только если вы вручную вызываете kcp.update

```lua
function kcp.update()
```

Обновляет все сокеты.
Следует вызывать вручную раз в 10-5000 мс (Желательно 10-50 для отзывчивой работы), если вы не используете автообновление

```lua
function kcp.set_interval(interval: int)
```
Изменяет интервал в миллисекундах, который автоматически будет устанавливаться каждому сокету при создании.
Значение по умолчанию - 50 мс